{"ast":null,"code":"var getSquaresForRow = function getSquaresForRow(rowNum, numRows, squares) {\n  var result = [];\n  var startingIndex = rowNum * numRows - 1;\n  var count = 0;\n\n  for (var i = startingIndex; i > -1; i--) {\n    if (count === numRows) break;\n    result.push(squares[i]);\n    count++;\n  }\n\n  return result;\n};\n\nvar getSquaresForCol = function getSquaresForCol(colNum, numCols, squares) {\n  var result = [];\n  var count = 0;\n  var startingIndex = colNum - 1;\n\n  for (var i = 0; i < numCols; i++) {\n    result.push(squares[startingIndex + numCols * count]);\n    count++;\n  }\n\n  return result;\n}; // 0  1  2  3\n// 4  5  6  7\n// 8  9  10 11\n// 12 13 14 15 \n\n\nvar getSquaresDiagonalDownRight = function getSquaresDiagonalDownRight(numCols, squares) {\n  var result = [];\n  var count = 0;\n  var startingIndex = 0;\n\n  for (var i = 0; i < numCols; i++) {\n    var constant = count > 0 ? 1 : 0;\n    result.push(squares[startingIndex + (numCols * count + constant * i)]);\n    count++;\n  }\n\n  return result;\n};\n\nvar getSquaresDiagonalUpRight = function getSquaresDiagonalUpRight(numCols, squares) {\n  var result = [];\n  var count = 0;\n  var startingIndex = numCols - 1;\n\n  for (var i = 0; i < numCols; i++) {\n    result.push(squares[startingIndex + (numCols - 1) * count]);\n    count++;\n  }\n\n  return result;\n};\n\nexport var checkForRewards = function checkForRewards(board) {\n  var numRowCols = Math.sqrt(board.numSquares);\n  var rewardOptions = [// 'wholeBoard' is account for later\n  'row1', 'row2', 'row3', 'row4', 'row5', 'column1', 'column2', 'column3', 'column4', 'column5', 'diagonalUpRight', 'diagonalDownRight'];\n  var squares = board.squares; // narrow down to reward options that are available, based on board size\n\n  rewardOptions = rewardOptions.filter(function (reward) {\n    return reward.slice(-1) <= numRowCols || reward.slice(-1).match(/[a-z]/i);\n  }); // organize all the rows, cols, diagonals\n\n  var divisions = [{\n    name: 'wholeBoard',\n    squares: squares\n  }];\n  rewardOptions.map(function (reward) {\n    if (reward.substring(0, 3) === 'row') {\n      divisions.push({\n        name: reward,\n        squares: getSquaresForRow(reward.slice(-1), numRowCols, squares)\n      });\n    } else if (reward.substring(0, 3) === 'col') {\n      divisions.push({\n        name: reward,\n        squares: getSquaresForCol(reward.slice(-1), numRowCols, squares)\n      });\n    } else if (reward === 'diagonalUpRight') {\n      divisions.push({\n        name: reward,\n        squares: getSquaresDiagonalUpRight(numRowCols, squares)\n      });\n    } else {\n      divisions.push({\n        name: reward,\n        squares: getSquaresDiagonalDownRight(numRowCols, squares)\n      });\n    }\n  }); // get the divisions for which every task is complete\n\n  var completed = [];\n  divisions.map(function (division) {\n    var complete = true;\n    division.squares.map(function (square) {\n      if (!square.complete) {\n        complete = false;\n      }\n    });\n\n    if (complete) {\n      completed.push(division.name);\n    }\n  });\n  return completed;\n};","map":{"version":3,"sources":["/Users/spencerford/Documents/DEVyall/PersonalProjects/CorporateBingoWeb/funcs/boardLogic.js"],"names":["getSquaresForRow","rowNum","numRows","squares","result","startingIndex","count","i","push","getSquaresForCol","colNum","numCols","getSquaresDiagonalDownRight","constant","getSquaresDiagonalUpRight","checkForRewards","board","numRowCols","Math","sqrt","numSquares","rewardOptions","filter","reward","slice","match","divisions","name","map","substring","completed","division","complete","square"],"mappings":"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","sourcesContent":["const getSquaresForRow = (rowNum, numRows, squares) => {\n    let result = [];\n    const startingIndex = (rowNum * numRows) - 1;\n    let count = 0;\n    for(let i = startingIndex; i > -1; i--){\n        if(count === numRows) break\n        result.push(squares[i]);\n        count++;\n    }\n    return result;\n}\n\nconst getSquaresForCol = (colNum, numCols, squares) => {\n    let result = [];\n    let count = 0;\n    let startingIndex = colNum - 1;\n    for(let i = 0; i < numCols; i++){\n        result.push(squares[startingIndex + (numCols * count)]);\n        count++;\n    }\n    return result;\n}\n\n// 0  1  2  3\n// 4  5  6  7\n// 8  9  10 11\n// 12 13 14 15 \n\nconst getSquaresDiagonalDownRight = (numCols, squares) => {\n    let result = [];\n    let count = 0;\n    let startingIndex = 0;\n    for(let i = 0; i < numCols; i++){\n        let constant = count > 0 ? 1 : 0\n        result.push(squares[startingIndex + ((numCols * count) + (constant * i))]);\n        count++;\n    }\n    return result;\n}\n\nconst getSquaresDiagonalUpRight = (numCols, squares) => {\n    let result = [];\n    let count = 0;\n    let startingIndex = numCols - 1;\n    for(let i = 0; i < numCols; i++){\n        result.push(squares[startingIndex + ((numCols - 1) * count)]);\n        count++;\n    }\n    return result;\n}\n\nexport const checkForRewards = (board) => {\n    const numRowCols = Math.sqrt(board.numSquares);\n    let rewardOptions = [\n        // 'wholeBoard' is account for later\n        'row1',\n        'row2',\n        'row3',\n        'row4',\n        'row5',\n        'column1',\n        'column2',\n        'column3',\n        'column4',\n        'column5',\n        'diagonalUpRight',\n        'diagonalDownRight',\n    ]\n    const squares = board.squares;\n\n    // narrow down to reward options that are available, based on board size\n    rewardOptions = rewardOptions.filter(reward => reward.slice(-1) <= numRowCols || reward.slice(-1).match(/[a-z]/i));\n\n    // organize all the rows, cols, diagonals\n    let divisions = [\n        {\n            name: 'wholeBoard',\n            squares: squares,\n        }\n    ]\n\n    rewardOptions.map(reward => {\n        if(reward.substring(0, 3) === 'row'){\n            divisions.push({\n                    name: reward,\n                    squares: getSquaresForRow(reward.slice(-1), numRowCols, squares),\n                }\n            );\n        } else if(reward.substring(0, 3) === 'col'){\n            divisions.push(\n                {\n                    name: reward,\n                    squares: getSquaresForCol(reward.slice(-1), numRowCols, squares)\n                }\n            );\n        } else if (reward === 'diagonalUpRight') {\n            divisions.push(\n                {\n                    name: reward,\n                    squares: getSquaresDiagonalUpRight(numRowCols, squares),\n                }\n            );\n        } else {\n            divisions.push(\n                {\n                    name: reward,\n                    squares: getSquaresDiagonalDownRight(numRowCols, squares),\n                }\n            );\n        }\n    })\n\n    // get the divisions for which every task is complete\n    let completed = [];\n    divisions.map(division => {\n        let complete = true;\n        division.squares.map(square => {\n            if(!square.complete){\n                complete = false;\n            }\n        })\n        if(complete){\n            completed.push(division.name);\n        }\n    })\n    return completed;\n\n}"]},"metadata":{},"sourceType":"module"}